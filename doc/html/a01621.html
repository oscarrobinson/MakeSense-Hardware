<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Contiki 2.6: platform/sensinode/dev/m25p16.c File Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.6
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_da81161b528b307837d2c2604d1aafcb.html">platform</a>      </li>
      <li class="navelem"><a class="el" href="dir_9f7c3ae195d7387d42137819fe980698.html">sensinode</a>      </li>
      <li class="navelem"><a class="el" href="dir_aa4731f2a7009db4830500e0ed9e9d10.html">dev</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">m25p16.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides functions to control the M25P16 on sensinode N740s.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="a01627_source.html">dev/n740.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a01622_source.html">dev/m25p16.h</a>&quot;</code><br/>
<code>#include &quot;sys/clock.h&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00455_source.html">sys/energest.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="a00781_source.html">cc2430_sfr.h</a>&quot;</code><br/>
</div>
<p><a href="a01621_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a39bed720ac92d59a37ad9a2fc8ced923">m25p16_wren</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Enable (WREN) instruction.  <a href="#a39bed720ac92d59a37ad9a2fc8ced923"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1fc99d85c5850f114a3d39368d2cb7c3"></a><!-- doxytag: member="m25p16.c::m25p16_wrdi" ref="a1fc99d85c5850f114a3d39368d2cb7c3" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a1fc99d85c5850f114a3d39368d2cb7c3">m25p16_wrdi</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Disable (WRDI) instruction. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a229511f6d7b36488e29883b904125670">m25p16_rdid</a> (struct <a class="el" href="a00060.html">m25p16_rdid</a> *rdid)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Identifier (RDID)instruction.  <a href="#a229511f6d7b36488e29883b904125670"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Status Register (RDSR) instruction.  <a href="#aca2ffc91878cb343e1f151a0f38778eb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a7d08feb122ca405e2130cc1a3c75c643">m25p16_wrsr</a> (uint8_t val)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Write Status Register (WRSR) instruction.  <a href="#a7d08feb122ca405e2130cc1a3c75c643"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a696ab02660ecbb25862366e5421a9771">m25p16_read</a> (uint8_t *addr, uint8_t *buff, uint8_t buff_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read Data Bytes (READ) instruction.  <a href="#a696ab02660ecbb25862366e5421a9771"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a405e8e8161d16e1579f926421c96e760">m25p16_pp</a> (uint8_t *addr, uint8_t *buff, uint8_t buff_len)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Program Page (PP) instruction.  <a href="#a405e8e8161d16e1579f926421c96e760"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a420d47d32f08857620f020af7a85b6f1">m25p16_se</a> (uint8_t s)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sector Erase (SE) instruction.  <a href="#a420d47d32f08857620f020af7a85b6f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#a6a5feabad55c0b533d368773de2869d7">m25p16_be</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bulk Erase (SE) instruction.  <a href="#a6a5feabad55c0b533d368773de2869d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#ac8cbc51dabc5aa595f9d0acf675a711a">m25p16_dp</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep Power Down (DP) instruction.  <a href="#ac8cbc51dabc5aa595f9d0acf675a711a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#af894e635b54a8626d9a129c8c87dcbfb">m25p16_res</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release from Deep Power Down (RES) instruction.  <a href="#af894e635b54a8626d9a129c8c87dcbfb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="a01621.html#ada69119d877cfabd3105953578163eb3">m25p16_res_res</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Release Deep Power Down.  <a href="#ada69119d877cfabd3105953578163eb3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file provides functions to control the M25P16 on sensinode N740s. </p>
<p>This is a Numonyx Forte Serial Flash Memory (16Mbit) The S signal (Chip Select) is controlled via 0x02 on the 74HC595D The other instructions and timing are performed with bit bang</p>
<p>We can enable, disable, read/write data, erase pages, hold, enter/exit deep sleep etc.</p>
<p>Clock (C) =&gt; P1_5, Ser. I (D) =&gt; P1_6, Ser. O (Q) =&gt; P1_7, Hold =&gt; Pull Up, Write Prot =&gt; Pull Up, Chip Sel =&gt; 74HC595D (0x02)</p>
<p>This file can be placed in any bank.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>George Oikonomou - &lt;<a href="mailto:oikonomou@users.sourceforge.net">oikonomou@users.sourceforge.net</a>&gt; </dd></dl>

<p>Definition in file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a6a5feabad55c0b533d368773de2869d7"></a><!-- doxytag: member="m25p16.c::m25p16_be" ref="a6a5feabad55c0b533d368773de2869d7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#a6a5feabad55c0b533d368773de2869d7">m25p16_be</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bulk Erase (SE) instruction. </p>
<p>Delete the entire memory, by setting it's contents to all 0xFF (which will read as 0x00 by READ).</p>
<p>This function will set the WEL bit on the SR before attempting to write, so the calling function doesn't need to worry about this.</p>
<p>This call is asynchronous. It will return before the write cycle has completed. Thus, user software must check the WIP bit Write In Progress) before sending further instructions.</p>
<p>This instructions takes a very long time to complete and must be used with care. It can take up to 40 secs (yes, secs). A typical duration is 13 secs </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00263">263</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01621_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8cbc51dabc5aa595f9d0acf675a711a"></a><!-- doxytag: member="m25p16.c::m25p16_dp" ref="ac8cbc51dabc5aa595f9d0acf675a711a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#ac8cbc51dabc5aa595f9d0acf675a711a">m25p16_dp</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deep Power Down (DP) instruction. </p>
<p>Puts the device into its lowers power consumption mode (This is not the same as the stand-by mode caused by de-selecting the device). While the device is in DP, it will accept no instruction except a RES (Release from DP).</p>
<p>This call is asynchronous and will return as soon as the instruction sequence has been written but before the device has actually entered DP</p>
<p>Dropping to DP takes 3usec and Resuming from DP takes at least 1.8usec, so this sequence should not be used when the sleep interval is estimated to be short (read as: don't DP then RES then DP repeatedly) </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00273">273</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

</div>
</div>
<a class="anchor" id="a405e8e8161d16e1579f926421c96e760"></a><!-- doxytag: member="m25p16.c::m25p16_pp" ref="a405e8e8161d16e1579f926421c96e760" args="(uint8_t *addr, uint8_t *buff, uint8_t buff_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#a405e8e8161d16e1579f926421c96e760">m25p16_pp</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buff_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Program Page (PP) instruction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>3 byte array holding the write start address. MSB stored in addr[0] and LSB in addr[2] </td></tr>
    <tr><td class="paramname">buff</td><td>Pointer to a buffer with the data to be written </td></tr>
    <tr><td class="paramname">buff_len</td><td>Number of bytes to write, Maximum 256 bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>Write BUFF_LEN bytes stored in BUFF to flash, starting from location ADDR. BUFF_LEN may not exceed 256. ADDR should point to a 3 byte array, with the address MSB stored in position 0 and LSB in position 2</p>
<p>If the start address + buff_len exceed page boundaries, the write will wrap to the start of the same page (the page at addr[2:1]).</p>
<p>The bytes will be inverted before being written, so that a value of 0xFF will be written as 0x00 (and subsequently correctly read as 0xFF by READ)</p>
<p>This function will set the WEL bit on the SR before attempting to write, so the calling function doesn't need to worry about this.</p>
<p>This call is asynchronous. It will return before the write cycle has completed. Thus, user software must check the WIP bit Write In Progress) before sending further instructions. This can take up to 5 msecs (typical duration for a 256 byte write is 640 usec) </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00224">224</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01621_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="a229511f6d7b36488e29883b904125670"></a><!-- doxytag: member="m25p16.c::m25p16_rdid" ref="a229511f6d7b36488e29883b904125670" args="(struct m25p16_rdid *rdid)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a00060.html">m25p16_rdid</a> </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="a00060.html">m25p16_rdid</a> *&#160;</td>
          <td class="paramname"><em>rdid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read Identifier (RDID)instruction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rdid</td><td>Pointer to a struct which will hold the information returned by the RDID instruction </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="a01621_source.html#l00149">149</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01622_source.html#l00096">m25p16_rdid::mem_size</a>, <a class="el" href="a01622_source.html#l00095">m25p16_rdid::mem_type</a>, <a class="el" href="a01622_source.html#l00098">m25p16_rdid::uid</a>, and <a class="el" href="a01622_source.html#l00097">m25p16_rdid::uid_len</a>.</p>

</div>
</div>
<a class="anchor" id="aca2ffc91878cb343e1f151a0f38778eb"></a><!-- doxytag: member="m25p16.c::m25p16_rdsr" ref="aca2ffc91878cb343e1f151a0f38778eb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a01622.html#aca2ffc91878cb343e1f151a0f38778eb">m25p16_rdsr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read Status Register (RDSR) instruction. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Value of the status register</dd></dl>
<p>Reads and returns the value of the status register on the Flash Chip </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00167">167</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

</div>
</div>
<a class="anchor" id="a696ab02660ecbb25862366e5421a9771"></a><!-- doxytag: member="m25p16.c::m25p16_read" ref="a696ab02660ecbb25862366e5421a9771" args="(uint8_t *addr, uint8_t *buff, uint8_t buff_len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#a696ab02660ecbb25862366e5421a9771">m25p16_read</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>buff_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read Data Bytes (READ) instruction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>3 byte array holding the read start address. MSB stored in addr[0] and LSB in addr[2] </td></tr>
    <tr><td class="paramname">buff</td><td>Pointer to a buffer to hold the read bytes. </td></tr>
    <tr><td class="paramname">buff_len</td><td>Number of bytes to read. buff must be long enough to hold buff_len bytes</td></tr>
  </table>
  </dd>
</dl>
<p>The bytes will be inverted after being read, so that a value of 0xFF (empty) in the flash will read as 0x00 </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00193">193</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

</div>
</div>
<a class="anchor" id="af894e635b54a8626d9a129c8c87dcbfb"></a><!-- doxytag: member="m25p16.c::m25p16_res" ref="af894e635b54a8626d9a129c8c87dcbfb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#af894e635b54a8626d9a129c8c87dcbfb">m25p16_res</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release from Deep Power Down (RES) instruction. </p>
<p>Take the device out of the Deep Power Down mode and bring it to standby. Does not read the electronic signature.</p>
<p>This call is synchronous. When it returns the device will be in standby mode.</p>
<p>Dropping to DP takes 3usec and Resuming from DP takes at least 1.8usec, so this sequence should not be used when the sleep interval is estimated to be short (read as: don't DP then RES then DP repeatedly) </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00284">284</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01622_source.html#l00116">M25P16_WIP</a>.</p>

</div>
</div>
<a class="anchor" id="ada69119d877cfabd3105953578163eb3"></a><!-- doxytag: member="m25p16.c::m25p16_res_res" ref="ada69119d877cfabd3105953578163eb3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="a01622.html#ada69119d877cfabd3105953578163eb3">m25p16_res_res</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Release Deep Power Down. </p>
<p>Release from Deep Power Down (RES) and Read Electronic Signature instruction.</p>
<p>Read and return the Electronic Signature must return 0x14</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The old style Electronic Signature. This must be 0x14 </dd></dl>

<p>Definition at line <a class="el" href="a01621_source.html#l00299">299</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01622_source.html#l00116">M25P16_WIP</a>.</p>

</div>
</div>
<a class="anchor" id="a420d47d32f08857620f020af7a85b6f1"></a><!-- doxytag: member="m25p16.c::m25p16_se" ref="a420d47d32f08857620f020af7a85b6f1" args="(uint8_t s)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#a420d47d32f08857620f020af7a85b6f1">m25p16_se</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sector Erase (SE) instruction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The number of the sector to be erased</td></tr>
  </table>
  </dd>
</dl>
<p>Delete the entire sector number s, by setting it's contents to all 0xFF (which will read as 0x00 by READ). The flash is broken down into 32 sectors, 64 KBytes each.</p>
<p>This function will set the WEL bit on the SR before attempting to write, so the calling function doesn't need to worry about this.</p>
<p>This call is asynchronous. It will return before the write cycle has completed. Thus, user software must check the WIP bit Write In Progress) before sending further instructions. This can take up to 3 secs (typical duration 600 msec) </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00248">248</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01621_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
<a class="anchor" id="a39bed720ac92d59a37ad9a2fc8ced923"></a><!-- doxytag: member="m25p16.c::m25p16_wren" ref="a39bed720ac92d59a37ad9a2fc8ced923" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#a39bed720ac92d59a37ad9a2fc8ced923">m25p16_wren</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write Enable (WREN) instruction. </p>
<p>Completing a WRDI, PP, SE, BE and WRSR resets the write enable latch bit, so this instruction should be used every time before trying to write. </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00131">131</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01622_source.html#l00125">M25P16_WEL</a>.</p>

<p>Referenced by <a class="el" href="a01621_source.html#l00263">m25p16_be()</a>, <a class="el" href="a01621_source.html#l00224">m25p16_pp()</a>, <a class="el" href="a01621_source.html#l00248">m25p16_se()</a>, and <a class="el" href="a01621_source.html#l00180">m25p16_wrsr()</a>.</p>

</div>
</div>
<a class="anchor" id="a7d08feb122ca405e2130cc1a3c75c643"></a><!-- doxytag: member="m25p16.c::m25p16_wrsr" ref="a7d08feb122ca405e2130cc1a3c75c643" args="(uint8_t val)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="a01622.html#a7d08feb122ca405e2130cc1a3c75c643">m25p16_wrsr</a> </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Write Status Register (WRSR) instruction. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>Value to be written to the status register</td></tr>
  </table>
  </dd>
</dl>
<p>This instruction does not afect bits 6, 5, 1 and 0 of the SR. </p>

<p>Definition at line <a class="el" href="a01621_source.html#l00180">180</a> of file <a class="el" href="a01621_source.html">m25p16.c</a>.</p>

<p>References <a class="el" href="a01621_source.html#l00131">m25p16_wren()</a>.</p>

</div>
</div>
</div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 13 2013 10:57:30 for Contiki 2.6 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
