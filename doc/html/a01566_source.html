<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Contiki 2.6: platform/OrisenStamp/dev/include/ff.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">Contiki 2.6
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_6c3864e3852bd4b51280f5788e7facd1.html">platform</a>      </li>
      <li class="navelem"><a class="el" href="dir_3e0982f54ae34001bc1c03e33a5a1c23.html">OrisenStamp</a>      </li>
      <li class="navelem"><a class="el" href="dir_21eb3be1420d66ab3138c17febba88c5.html">dev</a>      </li>
      <li class="navelem"><a class="el" href="dir_230747d7ec97eff88778b6991fcd1266.html">include</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ff.h</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*---------------------------------------------------------------------------/</span>
<a name="l00002"></a>00002 <span class="comment">/  FatFs - FAT file system module include file  R0.09     (C)ChaN, 2011</span>
<a name="l00003"></a>00003 <span class="comment">/----------------------------------------------------------------------------/</span>
<a name="l00004"></a>00004 <span class="comment">/ FatFs module is a generic FAT file system module for small embedded systems.</span>
<a name="l00005"></a>00005 <span class="comment">/ This is a free software that opened for education, research and commercial</span>
<a name="l00006"></a>00006 <span class="comment">/ developments under license policy of following trems.</span>
<a name="l00007"></a>00007 <span class="comment">/</span>
<a name="l00008"></a>00008 <span class="comment">/  Copyright (C) 2011, ChaN, all right reserved.</span>
<a name="l00009"></a>00009 <span class="comment">/</span>
<a name="l00010"></a>00010 <span class="comment">/ * The FatFs module is a free software and there is NO WARRANTY.</span>
<a name="l00011"></a>00011 <span class="comment">/ * No restriction on use. You can use, modify and redistribute it for</span>
<a name="l00012"></a>00012 <span class="comment">/   personal, non-profit or commercial product UNDER YOUR RESPONSIBILITY.</span>
<a name="l00013"></a>00013 <span class="comment">/ * Redistributions of source code must retain the above copyright notice.</span>
<a name="l00014"></a>00014 <span class="comment">/</span>
<a name="l00015"></a>00015 <span class="comment">/----------------------------------------------------------------------------*/</span>
<a name="l00016"></a>00016 
<a name="l00017"></a>00017 <span class="preprocessor">#ifndef _FATFS</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define _FATFS  6502    </span><span class="comment">/* Revision ID */</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
<a name="l00022"></a>00022 <span class="preprocessor">#endif</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &quot;integer.h&quot;</span>    <span class="comment">/* Basic integer types */</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &quot;ffconf.h&quot;</span>             <span class="comment">/* FatFs configuration options */</span>
<a name="l00026"></a>00026 
<a name="l00027"></a>00027 <span class="preprocessor">#if _FATFS != _FFCONF</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span><span class="preprocessor">#error Wrong configuration file (ffconf.h).</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 
<a name="l00033"></a>00033 <span class="comment">/* Definitions of volume management */</span>
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="preprocessor">#if _MULTI_PARTITION            </span><span class="comment">/* Multiple partition configuration */</span>
<a name="l00036"></a>00036 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00037"></a>00037         BYTE pd;        <span class="comment">/* Physical drive number */</span>
<a name="l00038"></a>00038         BYTE pt;        <span class="comment">/* Partition: 0:Auto detect, 1-4:Forced partition) */</span>
<a name="l00039"></a>00039 } PARTITION;
<a name="l00040"></a>00040 <span class="keyword">extern</span> PARTITION VolToPart[];   <span class="comment">/* Volume - Partition resolution table */</span>
<a name="l00041"></a>00041 <span class="preprocessor">#define LD2PD(vol) (VolToPart[vol].pd)  </span><span class="comment">/* Get physical drive number */</span>
<a name="l00042"></a>00042 <span class="preprocessor">#define LD2PT(vol) (VolToPart[vol].pt)  </span><span class="comment">/* Get partition index */</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#else                                           </span><span class="comment">/* Single partition configuration */</span>
<a name="l00045"></a>00045 <span class="preprocessor">#define LD2PD(vol) (vol)        </span><span class="comment">/* Each logical drive is bound to the same physical drive number */</span>
<a name="l00046"></a>00046 <span class="preprocessor">#define LD2PT(vol) 0            </span><span class="comment">/* Always mounts the 1st partition or in SFD */</span>
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="comment">/* Type of path name strings on FatFs API */</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="preprocessor">#if _LFN_UNICODE                        </span><span class="comment">/* Unicode string */</span>
<a name="l00055"></a>00055 <span class="preprocessor">#if !_USE_LFN</span>
<a name="l00056"></a>00056 <span class="preprocessor"></span><span class="preprocessor">#error _LFN_UNICODE must be 0 in non-LFN cfg.</span>
<a name="l00057"></a>00057 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00058"></a>00058 <span class="preprocessor"></span><span class="preprocessor">#ifndef _INC_TCHAR</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="keyword">typedef</span> WCHAR TCHAR;
<a name="l00060"></a>00060 <span class="preprocessor">#define _T(x) L ## x</span>
<a name="l00061"></a>00061 <span class="preprocessor"></span><span class="preprocessor">#define _TEXT(x) L ## x</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span>
<a name="l00064"></a>00064 <span class="preprocessor">#else                                           </span><span class="comment">/* ANSI/OEM string */</span>
<a name="l00065"></a>00065 <span class="preprocessor">#ifndef _INC_TCHAR</span>
<a name="l00066"></a>00066 <span class="preprocessor"></span><span class="keyword">typedef</span> <span class="keywordtype">char</span> TCHAR;
<a name="l00067"></a>00067 <span class="preprocessor">#define _T(x) x</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span><span class="preprocessor">#define _TEXT(x) x</span>
<a name="l00069"></a>00069 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span>
<a name="l00071"></a>00071 <span class="preprocessor">#endif</span>
<a name="l00072"></a>00072 <span class="preprocessor"></span>
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 
<a name="l00075"></a>00075 <span class="comment">/* File system object structure (FATFS) */</span>
<a name="l00076"></a>00076 
<a name="l00077"></a>00077 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00078"></a>00078         BYTE    fs_type;                <span class="comment">/* FAT sub-type (0:Not mounted) */</span>
<a name="l00079"></a>00079         BYTE    drv;                    <span class="comment">/* Physical drive number */</span>
<a name="l00080"></a>00080         BYTE    csize;                  <span class="comment">/* Sectors per cluster (1,2,4...128) */</span>
<a name="l00081"></a>00081         BYTE    n_fats;                 <span class="comment">/* Number of FAT copies (1,2) */</span>
<a name="l00082"></a>00082         BYTE    wflag;                  <span class="comment">/* win[] dirty flag (1:must be written back) */</span>
<a name="l00083"></a>00083         BYTE    fsi_flag;               <span class="comment">/* fsinfo dirty flag (1:must be written back) */</span>
<a name="l00084"></a>00084         WORD    id;                             <span class="comment">/* File system mount ID */</span>
<a name="l00085"></a>00085         WORD    n_rootdir;              <span class="comment">/* Number of root directory entries (FAT12/16) */</span>
<a name="l00086"></a>00086 <span class="preprocessor">#if _MAX_SS != 512</span>
<a name="l00087"></a>00087 <span class="preprocessor"></span>        WORD    ssize;                  <span class="comment">/* Bytes per sector (512, 1024, 2048 or 4096) */</span>
<a name="l00088"></a>00088 <span class="preprocessor">#endif</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span><span class="preprocessor">#if _FS_REENTRANT</span>
<a name="l00090"></a>00090 <span class="preprocessor"></span>        _SYNC_t sobj;                   <span class="comment">/* Identifier of sync object */</span>
<a name="l00091"></a>00091 <span class="preprocessor">#endif</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span><span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00093"></a>00093 <span class="preprocessor"></span>        DWORD   last_clust;             <span class="comment">/* Last allocated cluster */</span>
<a name="l00094"></a>00094         DWORD   free_clust;             <span class="comment">/* Number of free clusters */</span>
<a name="l00095"></a>00095         DWORD   fsi_sector;             <span class="comment">/* fsinfo sector (FAT32) */</span>
<a name="l00096"></a>00096 <span class="preprocessor">#endif</span>
<a name="l00097"></a>00097 <span class="preprocessor"></span><span class="preprocessor">#if _FS_RPATH</span>
<a name="l00098"></a>00098 <span class="preprocessor"></span>        DWORD   cdir;                   <span class="comment">/* Current directory start cluster (0:root) */</span>
<a name="l00099"></a>00099 <span class="preprocessor">#endif</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>        DWORD   n_fatent;               <span class="comment">/* Number of FAT entries (= number of clusters + 2) */</span>
<a name="l00101"></a>00101         DWORD   fsize;                  <span class="comment">/* Sectors per FAT */</span>
<a name="l00102"></a>00102         DWORD   fatbase;                <span class="comment">/* FAT start sector */</span>
<a name="l00103"></a>00103         DWORD   dirbase;                <span class="comment">/* Root directory start sector (FAT32:Cluster#) */</span>
<a name="l00104"></a>00104         DWORD   database;               <span class="comment">/* Data start sector */</span>
<a name="l00105"></a>00105         DWORD   winsect;                <span class="comment">/* Current sector appearing in the win[] */</span>
<a name="l00106"></a>00106         BYTE    win[_MAX_SS];   <span class="comment">/* Disk access window for Directory, FAT (and Data on tiny cfg) */</span>
<a name="l00107"></a>00107 } FATFS;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">/* File object structure (FIL) */</span>
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00114"></a>00114         FATFS*  fs;                             <span class="comment">/* Pointer to the owner file system object */</span>
<a name="l00115"></a>00115         WORD    id;                             <span class="comment">/* Owner file system mount ID */</span>
<a name="l00116"></a>00116         BYTE    flag;                   <span class="comment">/* File status flags */</span>
<a name="l00117"></a>00117         BYTE    pad1;
<a name="l00118"></a>00118         DWORD   fptr;                   <span class="comment">/* File read/write pointer (0 on file open) */</span>
<a name="l00119"></a>00119         DWORD   fsize;                  <span class="comment">/* File size */</span>
<a name="l00120"></a>00120         DWORD   sclust;                 <span class="comment">/* File start cluster (0 when fsize==0) */</span>
<a name="l00121"></a>00121         DWORD   clust;                  <span class="comment">/* Current cluster */</span>
<a name="l00122"></a>00122         DWORD   dsect;                  <span class="comment">/* Current data sector */</span>
<a name="l00123"></a>00123 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00124"></a>00124 <span class="preprocessor"></span>        DWORD   dir_sect;               <span class="comment">/* Sector containing the directory entry */</span>
<a name="l00125"></a>00125         BYTE*   dir_ptr;                <span class="comment">/* Ponter to the directory entry in the window */</span>
<a name="l00126"></a>00126 <span class="preprocessor">#endif</span>
<a name="l00127"></a>00127 <span class="preprocessor"></span><span class="preprocessor">#if _USE_FASTSEEK</span>
<a name="l00128"></a>00128 <span class="preprocessor"></span>        DWORD*  cltbl;                  <span class="comment">/* Pointer to the cluster link map table (null on file open) */</span>
<a name="l00129"></a>00129 <span class="preprocessor">#endif</span>
<a name="l00130"></a>00130 <span class="preprocessor"></span><span class="preprocessor">#if _FS_SHARE</span>
<a name="l00131"></a>00131 <span class="preprocessor"></span>        UINT    lockid;                 <span class="comment">/* File lock ID (index of file semaphore table) */</span>
<a name="l00132"></a>00132 <span class="preprocessor">#endif</span>
<a name="l00133"></a>00133 <span class="preprocessor"></span><span class="preprocessor">#if !_FS_TINY</span>
<a name="l00134"></a>00134 <span class="preprocessor"></span>        BYTE    buf[_MAX_SS];   <span class="comment">/* File data read/write buffer */</span>
<a name="l00135"></a>00135 <span class="preprocessor">#endif</span>
<a name="l00136"></a>00136 <span class="preprocessor"></span>} FIL;
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 
<a name="l00140"></a>00140 <span class="comment">/* Directory object structure (DIR) */</span>
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00143"></a>00143         FATFS*  fs;                             <span class="comment">/* Pointer to the owner file system object */</span>
<a name="l00144"></a>00144         WORD    id;                             <span class="comment">/* Owner file system mount ID */</span>
<a name="l00145"></a>00145         WORD    index;                  <span class="comment">/* Current read/write index number */</span>
<a name="l00146"></a>00146         DWORD   sclust;                 <span class="comment">/* Table start cluster (0:Root dir) */</span>
<a name="l00147"></a>00147         DWORD   clust;                  <span class="comment">/* Current cluster */</span>
<a name="l00148"></a>00148         DWORD   sect;                   <span class="comment">/* Current sector */</span>
<a name="l00149"></a>00149         BYTE*   dir;                    <span class="comment">/* Pointer to the current SFN entry in the win[] */</span>
<a name="l00150"></a>00150         BYTE*   fn;                             <span class="comment">/* Pointer to the SFN (in/out) {file[8],ext[3],status[1]} */</span>
<a name="l00151"></a>00151 <span class="preprocessor">#if _USE_LFN</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span>        WCHAR*  lfn;                    <span class="comment">/* Pointer to the LFN working buffer */</span>
<a name="l00153"></a>00153         WORD    lfn_idx;                <span class="comment">/* Last matched LFN index number (0xFFFF:No LFN) */</span>
<a name="l00154"></a>00154 <span class="preprocessor">#endif</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span>} DIR;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="comment">/* File status structure (FILINFO) */</span>
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="keyword">typedef</span> <span class="keyword">struct </span>{
<a name="l00162"></a>00162         DWORD   fsize;                  <span class="comment">/* File size */</span>
<a name="l00163"></a>00163         WORD    fdate;                  <span class="comment">/* Last modified date */</span>
<a name="l00164"></a>00164         WORD    ftime;                  <span class="comment">/* Last modified time */</span>
<a name="l00165"></a>00165         BYTE    fattrib;                <span class="comment">/* Attribute */</span>
<a name="l00166"></a>00166         TCHAR   fname[13];              <span class="comment">/* Short file name (8.3 format) */</span>
<a name="l00167"></a>00167 <span class="preprocessor">#if _USE_LFN</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span>        TCHAR*  lfname;                 <span class="comment">/* Pointer to the LFN buffer */</span>
<a name="l00169"></a>00169         UINT    lfsize;                 <span class="comment">/* Size of LFN buffer in TCHAR */</span>
<a name="l00170"></a>00170 <span class="preprocessor">#endif</span>
<a name="l00171"></a>00171 <span class="preprocessor"></span>} FILINFO;
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="comment">/* File function return code (FRESULT) */</span>
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
<a name="l00178"></a>00178         FR_OK = 0,                              <span class="comment">/* (0) Succeeded */</span>
<a name="l00179"></a>00179         FR_DISK_ERR,                    <span class="comment">/* (1) A hard error occured in the low level disk I/O layer */</span>
<a name="l00180"></a>00180         FR_INT_ERR,                             <span class="comment">/* (2) Assertion failed */</span>
<a name="l00181"></a>00181         FR_NOT_READY,                   <span class="comment">/* (3) The physical drive cannot work */</span>
<a name="l00182"></a>00182         FR_NO_FILE,                             <span class="comment">/* (4) Could not find the file */</span>
<a name="l00183"></a>00183         FR_NO_PATH,                             <span class="comment">/* (5) Could not find the path */</span>
<a name="l00184"></a>00184         FR_INVALID_NAME,                <span class="comment">/* (6) The path name format is invalid */</span>
<a name="l00185"></a>00185         FR_DENIED,                              <span class="comment">/* (7) Acces denied due to prohibited access or directory full */</span>
<a name="l00186"></a>00186         FR_EXIST,                               <span class="comment">/* (8) Acces denied due to prohibited access */</span>
<a name="l00187"></a>00187         FR_INVALID_OBJECT,              <span class="comment">/* (9) The file/directory object is invalid */</span>
<a name="l00188"></a>00188         FR_WRITE_PROTECTED,             <span class="comment">/* (10) The physical drive is write protected */</span>
<a name="l00189"></a>00189         FR_INVALID_DRIVE,               <span class="comment">/* (11) The logical drive number is invalid */</span>
<a name="l00190"></a>00190         FR_NOT_ENABLED,                 <span class="comment">/* (12) The volume has no work area */</span>
<a name="l00191"></a>00191         FR_NO_FILESYSTEM,               <span class="comment">/* (13) There is no valid FAT volume */</span>
<a name="l00192"></a>00192         FR_MKFS_ABORTED,                <span class="comment">/* (14) The f_mkfs() aborted due to any parameter error */</span>
<a name="l00193"></a>00193         FR_TIMEOUT,                             <span class="comment">/* (15) Could not get a grant to access the volume within defined period */</span>
<a name="l00194"></a>00194         FR_LOCKED,                              <span class="comment">/* (16) The operation is rejected according to the file shareing policy */</span>
<a name="l00195"></a>00195         FR_NOT_ENOUGH_CORE,             <span class="comment">/* (17) LFN working buffer could not be allocated */</span>
<a name="l00196"></a>00196         FR_TOO_MANY_OPEN_FILES, <span class="comment">/* (18) Number of open files &gt; _FS_SHARE */</span>
<a name="l00197"></a>00197         FR_INVALID_PARAMETER    <span class="comment">/* (19) Given parameter is invalid */</span>
<a name="l00198"></a>00198 } FRESULT;
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 <span class="comment">/*--------------------------------------------------------------*/</span>
<a name="l00203"></a>00203 <span class="comment">/* FatFs module application interface                           */</span>
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 FRESULT f_mount (BYTE, FATFS*);                                         <span class="comment">/* Mount/Unmount a logical drive */</span>
<a name="l00206"></a>00206 FRESULT f_open (FIL*, <span class="keyword">const</span> TCHAR*, BYTE);                      <span class="comment">/* Open or create a file */</span>
<a name="l00207"></a>00207 FRESULT f_read (FIL*, <span class="keywordtype">void</span>*, UINT, UINT*);                      <span class="comment">/* Read data from a file */</span>
<a name="l00208"></a>00208 FRESULT f_lseek (FIL*, DWORD);                                          <span class="comment">/* Move file pointer of a file object */</span>
<a name="l00209"></a>00209 FRESULT f_close (FIL*);                                                         <span class="comment">/* Close an open file object */</span>
<a name="l00210"></a>00210 FRESULT f_opendir (DIR*, <span class="keyword">const</span> TCHAR*);                         <span class="comment">/* Open an existing directory */</span>
<a name="l00211"></a>00211 FRESULT f_readdir (DIR*, FILINFO*);                                     <span class="comment">/* Read a directory item */</span>
<a name="l00212"></a>00212 FRESULT f_stat (<span class="keyword">const</span> TCHAR*, FILINFO*);                        <span class="comment">/* Get file status */</span>
<a name="l00213"></a>00213 FRESULT f_write (FIL*, <span class="keyword">const</span> <span class="keywordtype">void</span>*, UINT, UINT*);       <span class="comment">/* Write data to a file */</span>
<a name="l00214"></a>00214 FRESULT f_getfree (<span class="keyword">const</span> TCHAR*, DWORD*, FATFS**);      <span class="comment">/* Get number of free clusters on the drive */</span>
<a name="l00215"></a>00215 FRESULT f_truncate (FIL*);                                                      <span class="comment">/* Truncate file */</span>
<a name="l00216"></a>00216 FRESULT f_sync (FIL*);                                                          <span class="comment">/* Flush cached data of a writing file */</span>
<a name="l00217"></a>00217 FRESULT f_unlink (<span class="keyword">const</span> TCHAR*);                                        <span class="comment">/* Delete an existing file or directory */</span>
<a name="l00218"></a>00218 FRESULT f_mkdir (<span class="keyword">const</span> TCHAR*);                                         <span class="comment">/* Create a new directory */</span>
<a name="l00219"></a>00219 FRESULT f_chmod (<span class="keyword">const</span> TCHAR*, BYTE, BYTE);                     <span class="comment">/* Change attriburte of the file/dir */</span>
<a name="l00220"></a>00220 FRESULT f_utime (<span class="keyword">const</span> TCHAR*, <span class="keyword">const</span> FILINFO*);         <span class="comment">/* Change timestamp of the file/dir */</span>
<a name="l00221"></a>00221 FRESULT f_rename (<span class="keyword">const</span> TCHAR*, <span class="keyword">const</span> TCHAR*);          <span class="comment">/* Rename/Move a file or directory */</span>
<a name="l00222"></a>00222 FRESULT f_chdrive (BYTE);                                                       <span class="comment">/* Change current drive */</span>
<a name="l00223"></a>00223 FRESULT f_chdir (<span class="keyword">const</span> TCHAR*);                                         <span class="comment">/* Change current directory */</span>
<a name="l00224"></a>00224 FRESULT f_getcwd (TCHAR*, UINT);                                        <span class="comment">/* Get current directory */</span>
<a name="l00225"></a>00225 FRESULT f_forward (FIL*, UINT(*)(<span class="keyword">const</span> BYTE*,UINT), UINT, UINT*);       <span class="comment">/* Forward data to the stream */</span>
<a name="l00226"></a>00226 FRESULT f_mkfs (BYTE, BYTE, UINT);                                      <span class="comment">/* Create a file system on the drive */</span>
<a name="l00227"></a>00227 FRESULT f_fdisk (BYTE, <span class="keyword">const</span> DWORD[], <span class="keywordtype">void</span>*);           <span class="comment">/* Divide a physical drive into some partitions */</span>
<a name="l00228"></a>00228 <span class="keywordtype">int</span> f_putc (TCHAR, FIL*);                                                       <span class="comment">/* Put a character to the file */</span>
<a name="l00229"></a>00229 <span class="keywordtype">int</span> f_puts (<span class="keyword">const</span> TCHAR*, FIL*);                                        <span class="comment">/* Put a string to the file */</span>
<a name="l00230"></a>00230 <span class="keywordtype">int</span> f_printf (FIL*, <span class="keyword">const</span> TCHAR*, ...);                         <span class="comment">/* Put a formatted string to the file */</span>
<a name="l00231"></a>00231 TCHAR* f_gets (TCHAR*, <span class="keywordtype">int</span>, FIL*);                                      <span class="comment">/* Get a string from the file */</span>
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="preprocessor">#define f_eof(fp) (((fp)-&gt;fptr == (fp)-&gt;fsize) ? 1 : 0)</span>
<a name="l00234"></a>00234 <span class="preprocessor"></span><span class="preprocessor">#define f_error(fp) (((fp)-&gt;flag &amp; FA__ERROR) ? 1 : 0)</span>
<a name="l00235"></a>00235 <span class="preprocessor"></span><span class="preprocessor">#define f_tell(fp) ((fp)-&gt;fptr)</span>
<a name="l00236"></a>00236 <span class="preprocessor"></span><span class="preprocessor">#define f_size(fp) ((fp)-&gt;fsize)</span>
<a name="l00237"></a>00237 <span class="preprocessor"></span>
<a name="l00238"></a>00238 <span class="preprocessor">#ifndef EOF</span>
<a name="l00239"></a>00239 <span class="preprocessor"></span><span class="preprocessor">#define EOF (-1)</span>
<a name="l00240"></a>00240 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00241"></a>00241 <span class="preprocessor"></span>
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="comment">/*--------------------------------------------------------------*/</span>
<a name="l00246"></a>00246 <span class="comment">/* Additional user defined functions                            */</span>
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">/* RTC function */</span>
<a name="l00249"></a>00249 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00250"></a>00250 <span class="preprocessor"></span>DWORD get_fattime (<span class="keywordtype">void</span>);
<a name="l00251"></a>00251 <span class="preprocessor">#endif</span>
<a name="l00252"></a>00252 <span class="preprocessor"></span>
<a name="l00253"></a>00253 <span class="comment">/* Unicode support functions */</span>
<a name="l00254"></a>00254 <span class="preprocessor">#if _USE_LFN                                            </span><span class="comment">/* Unicode - OEM code conversion */</span>
<a name="l00255"></a>00255 WCHAR ff_convert (WCHAR, UINT);         <span class="comment">/* OEM-Unicode bidirectional conversion */</span>
<a name="l00256"></a>00256 WCHAR ff_wtoupper (WCHAR);                      <span class="comment">/* Unicode upper-case conversion */</span>
<a name="l00257"></a>00257 <span class="preprocessor">#if _USE_LFN == 3                                       </span><span class="comment">/* Memory functions */</span>
<a name="l00258"></a>00258 <span class="keywordtype">void</span>* ff_memalloc (UINT);                       <span class="comment">/* Allocate memory block */</span>
<a name="l00259"></a>00259 <span class="keywordtype">void</span> ff_memfree (<span class="keywordtype">void</span>*);                        <span class="comment">/* Free memory block */</span>
<a name="l00260"></a>00260 <span class="preprocessor">#endif</span>
<a name="l00261"></a>00261 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00262"></a>00262 <span class="preprocessor"></span>
<a name="l00263"></a>00263 <span class="comment">/* Sync functions */</span>
<a name="l00264"></a>00264 <span class="preprocessor">#if _FS_REENTRANT</span>
<a name="l00265"></a>00265 <span class="preprocessor"></span><span class="keywordtype">int</span> ff_cre_syncobj (BYTE, _SYNC_t*);<span class="comment">/* Create a sync object */</span>
<a name="l00266"></a>00266 <span class="keywordtype">int</span> ff_req_grant (_SYNC_t);                     <span class="comment">/* Lock sync object */</span>
<a name="l00267"></a>00267 <span class="keywordtype">void</span> ff_rel_grant (_SYNC_t);            <span class="comment">/* Unlock sync object */</span>
<a name="l00268"></a>00268 <span class="keywordtype">int</span> ff_del_syncobj (_SYNC_t);           <span class="comment">/* Delete a sync object */</span>
<a name="l00269"></a>00269 <span class="preprocessor">#endif</span>
<a name="l00270"></a>00270 <span class="preprocessor"></span>
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 
<a name="l00273"></a>00273 
<a name="l00274"></a>00274 <span class="comment">/*--------------------------------------------------------------*/</span>
<a name="l00275"></a>00275 <span class="comment">/* Flags and offset address                                     */</span>
<a name="l00276"></a>00276 
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="comment">/* File access control and file status flags (FIL.flag) */</span>
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="preprocessor">#define FA_READ                         0x01</span>
<a name="l00281"></a>00281 <span class="preprocessor"></span><span class="preprocessor">#define FA_OPEN_EXISTING        0x00</span>
<a name="l00282"></a>00282 <span class="preprocessor"></span><span class="preprocessor">#define FA__ERROR                       0x80</span>
<a name="l00283"></a>00283 <span class="preprocessor"></span>
<a name="l00284"></a>00284 <span class="preprocessor">#if !_FS_READONLY</span>
<a name="l00285"></a>00285 <span class="preprocessor"></span><span class="preprocessor">#define FA_WRITE                        0x02</span>
<a name="l00286"></a>00286 <span class="preprocessor"></span><span class="preprocessor">#define FA_CREATE_NEW           0x04</span>
<a name="l00287"></a>00287 <span class="preprocessor"></span><span class="preprocessor">#define FA_CREATE_ALWAYS        0x08</span>
<a name="l00288"></a>00288 <span class="preprocessor"></span><span class="preprocessor">#define FA_OPEN_ALWAYS          0x10</span>
<a name="l00289"></a>00289 <span class="preprocessor"></span><span class="preprocessor">#define FA__WRITTEN                     0x20</span>
<a name="l00290"></a>00290 <span class="preprocessor"></span><span class="preprocessor">#define FA__DIRTY                       0x40</span>
<a name="l00291"></a>00291 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00292"></a>00292 <span class="preprocessor"></span>
<a name="l00293"></a>00293 
<a name="l00294"></a>00294 <span class="comment">/* FAT sub type (FATFS.fs_type) */</span>
<a name="l00295"></a>00295 
<a name="l00296"></a>00296 <span class="preprocessor">#define FS_FAT12        1</span>
<a name="l00297"></a>00297 <span class="preprocessor"></span><span class="preprocessor">#define FS_FAT16        2</span>
<a name="l00298"></a>00298 <span class="preprocessor"></span><span class="preprocessor">#define FS_FAT32        3</span>
<a name="l00299"></a>00299 <span class="preprocessor"></span>
<a name="l00300"></a>00300 
<a name="l00301"></a>00301 <span class="comment">/* File attribute bits for directory entry */</span>
<a name="l00302"></a>00302 
<a name="l00303"></a>00303 <span class="preprocessor">#define AM_RDO  0x01    </span><span class="comment">/* Read only */</span>
<a name="l00304"></a>00304 <span class="preprocessor">#define AM_HID  0x02    </span><span class="comment">/* Hidden */</span>
<a name="l00305"></a>00305 <span class="preprocessor">#define AM_SYS  0x04    </span><span class="comment">/* System */</span>
<a name="l00306"></a>00306 <span class="preprocessor">#define AM_VOL  0x08    </span><span class="comment">/* Volume label */</span>
<a name="l00307"></a>00307 <span class="preprocessor">#define AM_LFN  0x0F    </span><span class="comment">/* LFN entry */</span>
<a name="l00308"></a>00308 <span class="preprocessor">#define AM_DIR  0x10    </span><span class="comment">/* Directory */</span>
<a name="l00309"></a>00309 <span class="preprocessor">#define AM_ARC  0x20    </span><span class="comment">/* Archive */</span>
<a name="l00310"></a>00310 <span class="preprocessor">#define AM_MASK 0x3F    </span><span class="comment">/* Mask of defined bits */</span>
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 <span class="comment">/* Fast seek feature */</span>
<a name="l00314"></a>00314 <span class="preprocessor">#define CREATE_LINKMAP  0xFFFFFFFF</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span>
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 
<a name="l00318"></a>00318 <span class="comment">/*--------------------------------*/</span>
<a name="l00319"></a>00319 <span class="comment">/* Multi-byte word access macros  */</span>
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="preprocessor">#if _WORD_ACCESS == 1   </span><span class="comment">/* Enable word access to the FAT structure */</span>
<a name="l00322"></a>00322 <span class="preprocessor">#define LD_WORD(ptr)            (WORD)(*(WORD*)(BYTE*)(ptr))</span>
<a name="l00323"></a>00323 <span class="preprocessor"></span><span class="preprocessor">#define LD_DWORD(ptr)           (DWORD)(*(DWORD*)(BYTE*)(ptr))</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span><span class="preprocessor">#define ST_WORD(ptr,val)        *(WORD*)(BYTE*)(ptr)=(WORD)(val)</span>
<a name="l00325"></a>00325 <span class="preprocessor"></span><span class="preprocessor">#define ST_DWORD(ptr,val)       *(DWORD*)(BYTE*)(ptr)=(DWORD)(val)</span>
<a name="l00326"></a>00326 <span class="preprocessor"></span><span class="preprocessor">#else                                   </span><span class="comment">/* Use byte-by-byte access to the FAT structure */</span>
<a name="l00327"></a>00327 <span class="preprocessor">#define LD_WORD(ptr)            (WORD)(((WORD)*((BYTE*)(ptr)+1)&lt;&lt;8)|(WORD)*(BYTE*)(ptr))</span>
<a name="l00328"></a>00328 <span class="preprocessor"></span><span class="preprocessor">#define LD_DWORD(ptr)           (DWORD)(((DWORD)*((BYTE*)(ptr)+3)&lt;&lt;24)|((DWORD)*((BYTE*)(ptr)+2)&lt;&lt;16)|((WORD)*((BYTE*)(ptr)+1)&lt;&lt;8)|*(BYTE*)(ptr))</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span><span class="preprocessor">#define ST_WORD(ptr,val)        *(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8)</span>
<a name="l00330"></a>00330 <span class="preprocessor"></span><span class="preprocessor">#define ST_DWORD(ptr,val)       *(BYTE*)(ptr)=(BYTE)(val); *((BYTE*)(ptr)+1)=(BYTE)((WORD)(val)&gt;&gt;8); *((BYTE*)(ptr)+2)=(BYTE)((DWORD)(val)&gt;&gt;16); *((BYTE*)(ptr)+3)=(BYTE)((DWORD)(val)&gt;&gt;24)</span>
<a name="l00331"></a>00331 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00332"></a>00332 <span class="preprocessor"></span>
<a name="l00333"></a>00333 <span class="preprocessor">#ifdef __cplusplus</span>
<a name="l00334"></a>00334 <span class="preprocessor"></span>}
<a name="l00335"></a>00335 <span class="preprocessor">#endif</span>
<a name="l00336"></a>00336 <span class="preprocessor"></span>
<a name="l00337"></a>00337 <span class="preprocessor">#endif </span><span class="comment">/* _FATFS */</span>
</pre></div></div><!-- contents -->


<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 28 2013 11:40:20 for Contiki 2.6 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
